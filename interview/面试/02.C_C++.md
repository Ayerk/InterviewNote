# 001.编译原理


# 002.排序算法
### [排序简介 - OI Wiki](https://oi-wiki.org/basic/sort-intro/)
### 快速排序
```
int partition(vector<int>& arr, int low, int high){
	int pivot = arr[high];
	int i = low;
	for(int j = low; j < high; j++)
		if(arr[j] < pivot) swap(arr[i++],arr[j]);
	swap(arr[i],arr[high]);
	return i;
}

void quicksort(vector<int>& arr, int low, int high){
	if(low >= high) return;
	int pi = partition(arr, low, high);

	quicksort(arr, low, pi - 1);
	quicksort(arr, pi + 1, high);
}
```
### 归并排序
```
void merge(vector<int>& arr, int low, int mid, int high){
	vector<int> tmp;
	int i = low, j = mid + 1;
	
	while(i <= mid && j <= high){
		if(arr[i] < arr[j]) tmp.push_back(arr[i++]);
		else tmp.push_back(arr[j++]);
	}
	
	while(i <= mid) tmp.push_back(arr[i++]);
	while(j <= high) tmp.push_back(arr[j++]);
	
	for(int k = 0; k < tmp.size(); k++){
		arr[low + k] = tmp[k];
	}
	return ;
}

void mergesort(vector<int>& arr, int low, int high){
	if(low >= high) return;
	int mid = low + ((high - low) >> 1);
	mergesort(arr, low, mid);
	mergesort(arr, mid + 1, high);
	merge(arr, low, mid, high);
}
```
### 堆排序
```
#节点关系：
iParent(i) = (i - 1) / 2; 
iLeftChild(i) = 2 * i + 1; 
iRightChild(i) = 2 * i + 2;
```

```
void adjust_down(vector<int>& arr, int start, int end){
	//获取父子节点下标
	int parent = start;
	int child = parent * 2 + 1;
	while(child <= end){
		if(child + 1 <= end && arr[child] < arr[child + 1]) child++;
		
		if(arr[parent] >= arr[child]) return;
		else{
			swap(arr[parent], arr[child]);
			parent = child;
			child = child * 2 + 1;
		}
	}
}

void heapsort(vector<int>& arr, int len){
	for(int i = ((len - 1) - 1) / 2; i >= 0; i--){
		adjust_down(arr, i, len - 1);
	}
	for(int i = len - 1; i > 0; i--){
		swap(arr[0], arr[i]);
		adjust_down(arr, 0, i - 1);
	}
}
```
### 希尔排序（改进的插入排序）
# 003.STL
### 一、容器
##### 1.vector
##### 2.map
##### 3.unordered_map
### 二、迭代器
### 三、算法

# 004.其他高频题
虚表指针、多态、
