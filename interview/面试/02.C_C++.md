# 001.编译原理


# 002.排序算法
### [排序简介 - OI Wiki](https://oi-wiki.org/basic/sort-intro/)
### 快速排序
```
int partition(vector<int>& arr, int low, int high){
	int pivot = arr[high];
	int i = low;
	for(int j = low; j < high; j++)
		if(arr[j] < pivot) swap(arr[i++],arr[j]);
	swap(arr[i],arr[high]);
	return i;
}

void quicksort(vector<int>& arr, int low, int high){
	if(low >= high) return;
	int pi = partition(arr, low, high);

	quicksort(arr, low, pi - 1);
	quicksort(arr, pi + 1, high);
}
```
### 归并排序
```
void merge(vector<int>& arr, int low, int mid, int high){
	vector<int> tmp;
	int i = low, j = mid + 1;
	
	while(i <= mid && j <= high){
		if(arr[i] < arr[j]) tmp.push_back(arr[i++]);
		else tmp.push_back(arr[j++]);
	}
	
	while(i <= mid) tmp.push_back(arr[i++]);
	while(j <= high) tmp.push_back(arr[j++]);
	
	for(int k = 0; k < tmp.size(); k++){
		arr[low + k] = tmp[k];
	}
	return ;
}

void mergesort(vector<int>& arr, int low, int high){
	if(low >= high) return;
	int mid = low + ((high - low) >> 1);
	mergesort(arr, low, mid);
	mergesort(arr, mid + 1, high);
	merge(arr, low, mid, high);
}
```
### 堆排序
```
void heapsort(vector<int>& arr, int low, int high){

}
```
# 003.STL